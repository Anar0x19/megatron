**Megatron**

Сервисно-оринтироеанный фреймворк на C++.

Рассмотрим типичную ситуацию, в которой бывают очень многие достаточно опытные программисты.
Нужно сделать таймер.
Eго делают так - создают новый поток, в него кидают лямбда функцию, в потоке ждут таймаут и выполняют лямбду.
Какие последствия такого действия?
1. Лямбда выполняется в другом потоке.
2. Все переменные, которые совместно используются классом, из которого вызвали таймер, нужно защитить мьютексами.
3. Затем нужно бороться с дедлоками.
В итоге ради реализации тривиального таймера мы создали такой ужас в коде, который исправить практически невозможно.
Причем сначала мы будем делать без мьютексов. Без нагрузки оно будет работать. Под нагрузкой - падать.
Затем мы пытаемся защититься мьютексами от одновременного доступа из двух потоков.
Все равно падает, подвисает на дедлоках. Дальше мы боремся с дедлоками. Все это время состояние проекта - осталось чуть-чуть исправить, а на деле - можно смело выбрасывать.
Стоит ли игра свеч?
Не проще ли сразу применить разумный архитектурный подход, чтобы таймер не создавал новые потоки.
А ведь кроме таймера есть еще много полезных вещей, но без таймера обойтись уж совсем невозможно.

Решение:

Сервис - это модуль, который имеет функцию обработки событий. 
Сервис посылает запрос сервису таймеру типа дай мне алерт через секунду.
Запрос к таймеру ложится в очередь событий, выгребается из нее и обрабатывается сервисом.
Дальше таймер посылает обратное событие в сервис консьюмер и это событие тоже попадает в очередь событий и потом обрабатывается в handleEvent.
Что имеем? Каждый сервис имеет только один мьютекс на очереди событий и блокировки на push и pop. Это сделать куда проще, чем блокировать использование абсолютно всех членов класса. 
handleEvent выполняется в одном потоке, поэтому защищать мьютексом нет необходимости.

Что может Мегатрон?
Скомпиляйте его и подкаталоге build/bin найдите test_http
Он гоняет apach benchmark на вебсервер мегатрона.
Результат: 270 тыс запросов в секунду. Сравниваем с nginx - 195 тыс.
Думаем в чем дело, наш сервер выдает текст из памяти, а nginx - с диска. Делаем чтобы отдавал с диска тот же файл - у нас результат 197,5 тыс запросов.
Работает быстрее чем nginx при прочих равных условиях чуть больше, чем на 1%. И это на C++!
Даже если софт медленнее нгинкса на 20%, то это уже хороший результат, а тут быстрее.

RPC
Мегатрон умеет передавать события по сети на другой нод. Клиент серверная архитектура строится при помощи 2 вызовов - sendEvent(destaddr....), а на сервере - passEvent() - отправить обратным маршрутом.
Просто берем и за 5 минут реализуем. При этом если мы создали облако и событие прошло через несколько нодов, то оно вернется обратным маршрутом. Причем можно послать событие из класса окна GUI, 
если класс отнаследовать от одного класса и вернется ответ также в этот класс GUI.

Можно потратить полчаса на реализацию дисплея для отображения каких-то технологических параметров, которые лежат на сервере.

В build/bin есть тест test_http_rpc
Это хттп сервер, который принимает запрос, затем делает запрос на другой нод, ждет ответ и затем делает ответ на изначально пришедший хттп запрос.
Оцените скорость, у меня показало 117 тыс запросов в сек.
Eще раз - это прием хттп запроса, запрос стороннему серверу, ожидание от него ответа и ответ хттп клиенту. 
Давайте соберем аналогичную систему на Апач кафка, какая там будет скорость? Позже проверю. Даже если Апач кафка не хуже по качеству нгинкса, то там будет одно лишнее прохождение евента до брокера.

То есть мы имеем, что в мегатроне брокер слинкован с handleEvent и не нужно тратить время на вытягивание евентов по сети из брокера.

Другие плюшки:
Сервис телнет. Eму любой сервис может заказать консольные команды, которые прилетят к заказчику, когда юзер введет ее на консоли. Так можно организовать управление бекендом либо просто просматривать какие-то внутренности. 
Примерно как на девайсах cisco.
В телнете автоматом организован help из всех зарегистрированных команд с их описанием и разбиение на каталоги.










